// 给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。​

// 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

// 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
// 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        if (len == 0){
            return 0;
        }
        // 有四种状态，分别是 1、当前可买入或已持有股票  2、两天前已卖出股票，当前已度过冷却期且还未购入
        //                3、今天卖出股票        4、当前处于冷却期
        int[][] dp = new int[len][4];
        // 初始化数组
        dp[0][0] = -prices[0];
        for (int i = 1; i < len; i++) {
            // 当天的状态一即可买入状态，更新考虑前一天的状态一以及
            // ① 若前一天是状态四即为冷却期，则今天已度过冷却期可以买入，当前现金数为前一天冷却期所拥有的钱减去买入价
            // ② 若前一天是状态二即不是冷却期，则今天现金数为前一天状态二即两天前就已卖出所拥有的现金数减去买入价
            // 取①②的最大值与前一天的状态一进行比较取最大值
            dp[i][0] = Math.max(dp[i-1][0], Math.max(dp[i-1][3], dp[i-1][1]) - prices[i]);
            // 当天的状态二即至少两天前已卖出股票并保持卖出状态，更新考虑
            // ① 前一天是状态二即不是冷却期，则今天等于前一天状态二的今天
            // ② 前一天是状态四即为冷却期，则今天等于前一天状态四所拥有的金额
            // 比较①②取最大值
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][3]);
            // 当天的状态三即今天卖出股票，更新即前一天持有金额加上今天股票价格
            dp[i][2] = dp[i-1][0] + prices[i];
            // 当天的状态四即今天为冷却期，则更新为前一天的卖出价即前一天的状态三的金额
            dp[i][3] = dp[i-1][2];
        }
        // 取最后一天各种卖出状态的最大值
        return Math.max(dp[len-1][3], Math.max(dp[len-1][1], dp[len-1][2]));
    }
}

// 还有其他方法